/*     （1） 数学建模
设幻方正中间数为n，幻和(即每行,每列与每对角线之和)为s。注意到
(中间一行)+(中间一列)+2*(两对角线)=6s
(上下行)+(左右列)=4s
两式相减即得
6n=2s → n=s/3                                               （1）
这意味着凡含n的行或列或对角线的三数中，除n之外的另两数与n相差等距。为此，设3阶幻方为: 
        n-x  n+w  n-y

        n+z   n   n-z                                              （2）

        n+y  n-w  n+x
 同时设方阵的两对角线的三数为大数在下(即x,y>0)，下面一行三数为大数在右(即x>y)。这样约定是避免重复统计解。
显见,上述3×3方阵的中间一行，中间一列与两对角线上三数之和均为3n。要使左右两列，上下两行的三数之和也为3n，当且仅当
     z=x-y
     w=x+y   (x>y)                                              （3）
同时易知9个素数中不能有偶素数2，因而x，y，z，w都只能是正偶数。
     （2） 穷举设计
对于键盘输入的整数s, 如果存在幻和为s的素数幻方，则s应为中间素数的3倍。若s不是3的整数倍，则对输入的s，输出“无解！”而退出。
设置a数组，数组元素清“0”。通过试商判别，寻找出[3,s]中的所有素数k，并标注a[k]=1，为以后的判断提供依据。
设n=s/3，若a[n]==0，知n不是素数，显然不存在幻和为s的素数幻，显示“无解！”后退出。
设幻方中的素数下界为c，上界为d。显然c=3，注意到d+n+c=s，则d≤2n-3。
注意到 n-y≥3,(n+y)+n+(n-y)=s  得 2n+y=s-(n-y)≤s-3  即 y≤s-2n-3
同理  x≤s-2n-3=n-3
在[2,n-3]中穷举y，在[y+2,n-3]穷举x，并按上述（3）式得z，w：
若出现x=2y，将导致z=y，方阵中出现两对相同的数，显然应予排除。
显然n-w是9个数中最小的，n+w是9个数中最大的。若n-w<c或n+w>d，已超出[c,d]界限，应予以排除。
检测方阵中其他8个数n-x，n+w，n-y，n+z，n-z，n+y，n-w，n+x是否同时为素数，引用变量t1,t2，t1*t2为8个数的标记之积。若t1*t2=0，即8个数中存在非素数，返回。否则，已找到一个三阶素数幻方解，按方阵格式输出并用变量m统计基本解的个数。这样处理，能较快的找出所有解，既无重复，也没有遗漏。
//此题重在数学分析*/
#include <stdio.h>
#include <string.h>
#include <math.h>

int pan[4000] = {0};
int su[1000] = {0};
int cnt = 0;

int main()
{
    pan[0] = pan[1] = 1;
    for (int i = 2; i <= 4000; i++)
    {
        if (!pan[i])
        {
            su[cnt] = i;
            cnt++;
        }
        for (int j = 0; i * su[j] <= 4000 && j < cnt; j++)
        {
            pan[i * su[j]] = 1;
            if (i % su[j] == 0)
            {
                break;
            }
        }
    }
    int c = 0;
    int d = 0;
    int sum = 0;
    scanf("%d,%d", &c, &d);
    for (int i = c; i <= d; i++)
    {
        if (pan[i])
        {
            continue;
        }
        for (int y = 2; y <= i - 3; y++)
        {
            for (int x = y + 2; x <= i - 3; x++)
            {
                if (x == 2 * y)
                {
                    continue;
                }
                int z = x - y;
                int w = x + y;
                if (i - w < c || i + w > d)
                {
                    continue;
                }
                if (pan[i - x] || pan[i + x] || pan[i + z] || pan[i - z] || pan[i + y] || pan[i - y] || pan[i + w] || pan[i - w])
                {
                    continue;
                }
                else
                {
                    sum++;
                }
            }
        }
    }
    printf("共%d个素数幻方\n", sum);
}
