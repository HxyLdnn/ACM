/*小s今天在玩一个地牢探险游戏。他一路过关斩将，但是每次都被boss斩于马下。小s气急败坏，最后去查了攻略，才发现原来这个游戏有隐藏房和超级隐藏房。如果找到这两个房间，小s的战斗力将得到极大提升，打败boss就是小菜一碟。小s的地牢可以用一张地图表示，这个地图有n行m列，每个房间都位于其中一个方格内，并且所有房间互相连通（哪怕没有隐藏房和超级隐藏房也是连通的，也就是不需要找到隐藏房和超级隐藏房就可以走遍其余所有房间）。小s想知道这两个房间可能出现的位置有几个，但他搞不懂房间可能出现的位置，你能帮帮他吗？
 
房间共有5种，每个房间都有不同特性。
 
普通房"N":最普通的房间，没有任何特性。
 
长条房"L":一种狭长的房间，若把其看做长方形的话，只会在短边上与其他房间连通。也就是说，当长条房的上方或下方出现房间时，左右不会出现房间，左右出现房间时，上下不会出现房间。
 
Boss房"B":可以与长条房和普通房相连，但一定不与隐藏房和超级隐藏房相连。
 
隐藏房：只与普通房相连，且至少与两个房间相连。
 
超级隐藏房：与且仅与一个房间相连，这个房间只可以是长条房和普通房。
 
"#"在地图上代表空地，隐藏房和超级隐藏房只会在空地上生成。
 
相连：位于一个房间上下左右四个方格之内视为相连。
 
值得注意的是，隐藏房和超级隐藏房的生成不会互相干扰,且只会生成在n行m列的范围内.−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
若长条房四周都没有房间，就无法得知长条房的具体朝向，此时要将长条房的横向和竖向的可能都包括进去。
换句话说，若长条房没有与其他房间相连，则四周都有可能生成超级隐藏房。
 

Input
第一行输入两个整数n,m代表迷宫地图的大小（1<=n,m<=10）.
接下来n行，每行m个字符，代表迷宫地图。这些字符只可能是N,L,B,#。
Output
输出两个整数，分别代表隐藏房可能出现的位置个数和超级隐藏房可能出现的位置个数，其间以空格相隔。

Sample Input
5 5
#####
#N###
#N#N#
#NNN#
#####
Sample Output
1 11
Hint
若把左上角当做（0,0），（2,2）周围有三个N可以生成隐藏房，（1,0），（2,0），（3,0），（0,1），（4,1），（1,2），（4,2），（1,3），（4,3），（2,4），（3,4）都可以生成超级隐藏房。

小s偷偷告诉你：这题其实不难哦！只要别被超长的题面吓到，耐心思考，一定可以做出来的！！！
 
hard version相比easy version只是多了一种房间类型，通过hard version 的代码一定可以通过easy version。*/

#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define PLL pair<ll, ll>
ll n, m, chaoji = 0, putong = 0;
ll numB, numN, numL;
char Map[50][50];
ll dx[4] = {-1, 0, 1, 0};
ll dy[4] = {0, 1, 0, -1};
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            cin >> Map[i][j];
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            numB = 0;
            numN = 0;
            numL = 0;
            ll flag = 1;
            if (Map[i][j] == '#')
            {
                for (int k = 0; k < 4; k++)
                {
                    ll x = i + dx[k];
                    ll y = j + dy[k];
                    if (x > 0 && x <= n && y > 0 && y <= m)
                    {
                        if (Map[x][y] == 'L')
                        {
                            if (k == 0)
                            {
                                if (Map[x][y + 1] == 'B' || Map[x][y + 1] == 'N' || Map[x][y - 1] == 'B' || Map[x][y - 1] == 'N' || Map[x][y - 1] == 'L' || Map[x][y + 1] == 'L')
                                    flag = 0;
                            }
                            if (k == 1)
                            {
                                if (Map[x + 1][y] == 'B' || Map[x + 1][y] == 'N' || Map[x - 1][y] == 'B' || Map[x - 1][y] == 'N' || Map[x + 1][y] == 'L' || Map[x - 1][y] == 'L')
                                    flag = 0;
                            }
                            if (k == 2)
                            {
                                if (Map[x][y + 1] == 'B' || Map[x][y + 1] == 'N' || Map[x][y - 1] == 'B' || Map[x][y - 1] == 'N' || Map[x][y + 1] == 'L' || Map[x][y - 1] == 'L')
                                    flag = 0;
                            }
                            if (k == 3)
                            {
                                if (Map[x + 1][y] == 'B' || Map[x + 1][y] == 'N' || Map[x - 1][y] == 'B' || Map[x - 1][y] == 'N' || Map[x + 1][y] == 'L' || Map[x - 1][y] == 'L')
                                    flag = 0;
                            }
                            numL++;
                        }
                        if (Map[x][y] == 'B')
                            numB++;
                        if (Map[x][y] == 'N')
                            numN++;
                    }
                }
                if (numB == 0 && flag == 1)
                {
                    if (numN == 1 || numL == 1)
                        chaoji++;
                    if (numN >= 2 && numL == 0)
                        putong++;
                }
            }
        }
    }
    cout << putong << ' ' << chaoji << '\n';
}
